Eddroid.Main = function(game){
  this.map;
  this.mapjson;
  this.player;
  this.cursors;
  this.blockedLayer;
  playMusic = true,
  this.music;
  this.bullet;
  this.bulletTime = 0;
  this.fireButton;
  this.addA;
  this.addS;
  this.addW;
  this.addD;
  this.playerDirection;
  this.enemies;
  this.rubies;
  this.ruby;
  this.destroy;
  this.flames;
  this.playerHit;
  this.rails;
  this.playerHit1;
  this.score = 0;
  this.scoreString;
  this.cascades;
  this.javascripts;
  this.lives = 10;
  this.livesString;

};
Eddroid.Main.prototype = {

  // All preloading is done in preload.js
  preload: function() {

  },


  create: function(){

    // setting playerDirection to 0 when using later for walking animations at angles
    this.playerDirection = 0;
    point = new Phaser.Point(0, 0);

    // 4800 x 4800 is the size of the map (150 tiles * 32 px/tile)
    this.world.setBounds(0,0,4800,4800);
    this.physics.startSystem(Phaser.Physics.ARCADE);
    map = this.add.sprite(0, 0, 'map');

    // Setting player in game as sprite in order to enable it to have physics i.e. health
    this.player = this.add.sprite(game.world.centerX, game.world.centerY + 400, 'Eddroid');
    this.player.health = 10;

    // Creating bullets (rubies) as a group in order to work with collision handlers
    rubies = this.add.group();
    rubies.enableBody = true;
    rubies.physicsBodyType = Phaser.Physics.ARCADE;
    this.nextShotAt = 0;
    this.shotDelay = 100;

    // Goes to fire function
    this.fire();

    // enabling player physics
    this.physics.enable(this.player, Phaser.Physics.ARCADE);
    this.player.body.drag.set(100);
    this.player.body.maxVelocity.set(200);

    // Enabling the necessary cursor keys Eddroid is going to use in-game
    cursors = this.input.keyboard.createCursorKeys();
    addA = this.input.keyboard.addKey(Phaser.Keyboard.A)
    addS = this.input.keyboard.addKey(Phaser.Keyboard.S)
    addW = this.input.keyboard.addKey(Phaser.Keyboard.W)
    addD = this.input.keyboard.addKey(Phaser.Keyboard.D)
    this.fireButton = this.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR)
    addP = this.input.keyboard.addKey(Phaser.Keyboard.P)

    // Creating explosion effect as a group in order to use as in collision handlers
    flames = this.add.group();
    flames.createMultiple(100, 'destroy');
    flames.forEach(this.setupEnemy, this);
    flames.forEach(this.setupRail, this)


    // camera feature to follow player around map and not be solely fixated on one quadrant
    this.camera.follow(this.player, Phaser.Camera.FOLLOW_TOPDOWN);
    this.player.body.collideWorldBounds = true;

    // Going through array of spritesheet (Eddroid.png) and creating animations for each movement
    this.player.animations.add('walk-down',[0,1,2,3,4,5,6,7]);
    this.player.animations.add('walk-up',[10,11,12,13,14,15,16]);
    this.player.animations.add('walk-right',[20,21,22,23,24]);
    this.player.animations.add('walk-left',[26,27,28,29,30]);

    // HTML5 enemy group, createMultiple (Once one is killed, 50 will spawn in its place)
    enemies = this.add.group();
    enemies.enableBody = true;
    enemies.physicsBodyType = Phaser.Physics.ARCADE;
    enemies.createMultiple(50, 'enemy');
    enemies.setAll('anchor.x', 0.5);
    enemies.setAll('anchor.y', 0.5);
    enemies.setAll('outOfBoundsKill', true);
    enemies.setAll('checkWorldBounds', true);

    this.nextEnemyAt = 0;
    this.enemyDelay = 60;

    // Same as enemies group but rails enemy
    rails = this.add.group();
    rails.enableBody = true;
    rails.physicsBodyType = Phaser.Physics.ARCADE;
    rails.createMultiple(60, 'rails');
    rails.setAll('anchor.x', 0.5);
    rails.setAll('anchor.y', 0.5);
    rails.setAll('outOfBoundsKill', true);
    rails.setAll('checkWorldBounds', true);


    this.nextRailAt = 0;
    this.railDelay = 50;

    // CSS enemy group
    cascades = this.add.group();
    cascades.enableBody = true;
    cascades.enableBody = true;
    cascades.physicsBodyType = Phaser.Physics.ARCADE;
    cascades.createMultiple(70, 'css');
    cascades.setAll('anchor.x', 0.5);
    cascades.setAll('anchor.y', 0.5);
    cascades.setAll('outOfBoundsKill', true);
    cascades.setAll('checkWorldBounds', true);

    this.nextCascadeAt = 0;
    this.cascadeDelay = 50;

    // Javascript enemy group
    javascripts = this.add.group();
    javascripts.enableBody = true;
    javascripts.enableBody = true;
    javascripts.physicsBodyType = Phaser.Physics.ARCADE;
    javascripts.createMultiple(80, 'javascript');
    javascripts.setAll('anchor.x', 0.5);
    javascripts.setAll('anchor.y', 0.5);
    javascripts.setAll('outOfBoundsKill', true);
    javascripts.setAll('checkWorldBounds', true);

    this.nextJavascriptAt = 0;
    this.javascriptDelay = 50;

    // Score feature + Fixed to camera keeps the score fixed on the canvas and not in a fixed coordinate postion on map
    scoreString = 'Score: ';
    scoreText = this.add.text(0, 0, this.score, { font: '30px Arial', fill: '#fff' });
    scoreText.fixedToCamera = true;
    scoreString.fixedToCamera = true;

    // Lives feature
    livesString = 'Lives: ';
    livesText = this.add.text(690, 0, this.lives, { font: '30px Arial', fill: '#fff' });
    livesText.fixedToCamera = true;
    livesString.fixedToCamera = true;


  },


  update:function() {

    var health = 10;

    var counter = 0;

    // When 1st arg and 2nd arg overlap, then collisionHandler function will come into effect.
    // The reason for creating everything in groups
    this.physics.arcade.collide(rubies, enemies, this.collisionHandler, null, this);
    this.physics.arcade.collide(rubies, rails, this.collisionHandler1, null, this);
    this.physics.arcade.collide(rubies, cascades, this.collisionHandler2, null, this);
    this.physics.arcade.collide(rubies, javascripts, this.collisionHandler3, null, this);

    // Delays on animations to make walking appear more fluid and not glitchy
    this.player.body.velocity.x = 0;
    this.player.body.velocity.y = 0;
    this.player.animations.getAnimation('walk-left').delay = 50;
    this.player.animations.getAnimation('walk-right').delay = 50;
    this.player.animations.getAnimation('walk-up').delay = 50;
    this.player.animations.getAnimation('walk-down').delay = 50;


    // Boolean logic to set animations to respective cursor keys
    if (cursors.left.isDown || addA.isDown)
    {
      this.player.animations.play('walk-left');
      this.player.body.velocity.x = -200;
      this.playerDirection = 270;

    }
    else if (cursors.right.isDown || addD.isDown)
    {
      this.player.animations.play('walk-right');
      this.player.body.velocity.x = 200;
      this.playerDirection = 90;
    }

    if (cursors.up.isDown || addW.isDown)
    {
      this.player.animations.play('walk-up');
      this.player.body.velocity.y = -200;
      this.playerDirection = 180;
    }
    else if (cursors.down.isDown || addS.isDown)
    {
      this.player.animations.play('walk-down');
      this.player.body.velocity.y = 200;
      this.playerDirection = 0;
    }

    if ((cursors.down.isDown && cursors.right.isDown) || (addS.isDown && addD.isDown))
    {
      this.player.animations.play('walk-right');
      this.player.body.velocity.x = 400;
      this.playerDirection = 90;
    }

    if ((cursors.down.isDown && cursors.left.isDown) || (addS.isDown && addA.isDown))
    {
      this.player.animations.play('walk-left');
      this.player.body.velocity.x = -400;
      this.playerDirection = 270;
    }

    if ((cursors.up.isDown && cursors.right.isDown) || (addW.isDown && addD.isDown))
    {
      this.player.animations.play('walk-right');
      this.player.body.velocity.x = 400;
      this.playerDirection = 90;
    }

    if ((cursors.up.isDown && cursors.left.isDown) || (addW.isDown && addA.isDown))
    {
      this.player.animations.play('walk-left');
      this.player.body.velocity.x = -400;
      this.playerDirection = 270;
    }

    // Pressing P will go to the managePausepause function created below
    if (addP.isDown)
    {
      this.managePause();
    }

    // fireButton (space bar) will go to fire function created below
    if(this.fireButton.isDown)
    {
      this.fire();
    }

    // Bringing flames to front of screen so they appear over the enemies
    this.game.world.bringToTop(flames);

    // enemy spawn details
    if (this.nextEnemyAt < this.time.now && enemies.countDead() > 0) {
      this.nextEnemyAt = this.time.now + this.enemyDelay;
      var enemy = enemies.getFirstExists(false);
      // this will spawn enemy at a random point along the x axis bc first arg is beginning coordinate of x and 2nd arg is 4800 (last coordinate on x axis)
      enemy.reset(this.rnd.integerInRange(0, 4800), 0);
      // this spawns enemies with a random speed inbetween 150 & 200
      enemy.body.velocity.y = this.rnd.integerInRange(150, 200);
    }

    if (this.nextEnemyAt < this.time.now && rails.countDead() > 0) {
      this.nextEnemyAt = this.time.now + this.enemyDelay;
      var rail = rails.getFirstExists(false);
      rail.reset(this.rnd.integerInRange(0, 4800), 0);
      rail.body.velocity.y = this.rnd.integerInRange(210, 250);
    }

    if (this.nextEnemyAt < this.time.now && cascades.countDead() > 0) {
      this.nextEnemyAt = this.time.now + this.enemyDelay;
      var cascade = cascades.getFirstExists(false);
      cascade.reset(this.rnd.integerInRange(0, 4800), 0);
      cascade.body.velocity.y = this.rnd.integerInRange(260, 300);
    }

    if (this.nextEnemyAt < this.time.now && javascripts.countDead() > 0) {
      this.nextEnemyAt = this.time.now + this.enemyDelay;
      var javascript = javascripts.getFirstExists(false);
      javascript.reset(this.rnd.integerInRange(0, 4800), 0);
      javascript.body.velocity.y = this.rnd.integerInRange(350, 600);
    }

    // Collision handlers created so when player and enemies overlap playerHit function will happen
    this.physics.arcade.collide(this.player, enemies, this.playerHit, null, this);
    this.physics.arcade.collide(this.player, rails, this.playerHit1, null, this);
    this.physics.arcade.collide(this.player, cascades, this.playerHit2, null, this);
    this.physics.arcade.collide(this.player, javascripts, this.playerHit3, null, this);


    if (this.nextEnemyAt < this.time.now && enemies.countDead() > 0) {}
    if (this.nextEnemyAt < this.time.now && rails.countDead() > 0) {}
    if (this.nextEnemyAt < this.time.now && cascades.countDead() > 0) {}
    if (this.nextEnemyAt < this.time.now && javascripts.countDead() > 0) {}

  },



  fire:function() {
    if (this.nextShotAt > this.time.now) {
      return;
    }

    this.nextShotAt = this.time.now + this.shotDelay;

    // When fire function is engaged rubies (bullets) will be created
    // Anchored on the player coordinates
    var ruby = rubies.create(this.player.x, this.player.y - 20, 'ruby');
    this.physics.enable(ruby, Phaser.Physics.ARCADE);
    // Player directions created in regards of right angles to have bullets leave player in correct direction
    if (this.playerDirection === 90 || this.playerDirection === 270) {
      ruby.body.velocity.x = this.playerDirection === 90 ? 500 : -500
    } else {
      ruby.body.velocity.y = this.playerDirection === 0 ? 500 : -500
    }
    // if walking right then bullets will exit and travel to the east
    if (this.playerDirection === 90) {
      ruby.anchor.setTo(-2.62, -2.1);
    // if walking left then bullets will exit and travel to the west
    } else if (this.playerDirection === 270) {
      ruby.anchor.setTo(0.4 , -2.1);
    // if walking down then bullets will exit and travel to the south
    } else if (this.playerDirection === 180) {
      ruby.anchor.setTo(-1.8, -2);
    // if walking up then bullets will exit and travel to the north
    } else if (this.playerDirection === 0) {
      ruby.anchor.setTo(-0.3, -4);
    } else {
      ruby.anchor.setTo(0, 0);
    }


  },


  setupEnemy: function(enemy) {
    enemy.anchor.x = 0.5;
    enemy.anchor.y = 0.5;
    enemy.animations.add('destroy');
  },

  setupRail: function(rail) {
    rail.anchor.x = 0.5;
    rail.anchor.y = 0.5;
    rail.animations.add('destroy');
  },

  setupCss: function(cascade) {
    cascade.anchor.x = 0.5;
    cascade.anchor.y = 0.5;
    cascade.animations.add('destroy');
  },

  setupJavascript: function(javascript) {
    javascript.anchor.x = 0.5;
    javascript.anchor.y = 0.5;
    javascript.animations.add('destroy');
  },


  // When ruby group and enemy group (HTML5) overlap
  collisionHandler: function(ruby, enemy) {
    // Both ruby and enemy will dissappear with the kill function (global function)
    ruby.kill();
    enemy.kill();

    // Score increments by 10
    this.score += 10;
    scoreText.text = scoreString + this.score;

    // the explosion animation is created
    var gone = flames.getFirstExists(false);
    gone.reset(enemy.body.x, enemy.body.y);
    gone.play('destroy', 20, false, true);
  },

  // When ruby group and rail group
  collisionHandler1: function(ruby, rail) {
    ruby.kill();
    rail.kill();

    this.score += 30;
    scoreText.text = scoreString + this.score;

    var gone = flames.getFirstExists(false);
    gone.reset(rail.body.x, rail.body.y);
    gone.play('destroy', 20, false, true);
  },

  // When ruby group and CSS group
  collisionHandler2: function(ruby, cascade) {
    ruby.kill();
    cascade.kill();

    this.score += 15;
    scoreText.text = scoreString + this.score;

    var gone = flames.getFirstExists(false);
    gone.reset(cascade.body.x, cascade.body.y);
    gone.play('destroy', 20, false, true);
  },

  // When ruby group and Javascript group
  collisionHandler3: function(ruby, javascript) {
    ruby.kill();
    javascript.kill();

    this.score += 50;
    scoreText.text = scoreString + this.score;

    var gone = flames.getFirstExists(false);
    gone.reset(javascript.body.x, javascript.body.y);
    gone.play('destroy', 20, false, true);
  },

 //Pause function
  managePause: function() {
    this.game.paused = true;
    var pausemenu = this.game.add.image(0,0,'pausemenu');
    pausemenu.fixedToCamera = true;
    addP.onDown.add(function(){
      pausemenu.destroy();
      this.game.paused = false;
    }, this);
  },

  // Same thing as enemy and ruby collision handler except meant for player and enemy now
  playerHit: function (player, enemy) {
    enemy.kill();

    this.score += 10;
    scoreText.text = scoreString + this.score;

    this.lives -= 1;
    livesText.text = livesString + this.lives;

    // So player won't dissapear (be killed) unless health reaches 1
    if (this.player.health > 1) {
      this.player.health --;
    } else {
      this.player.kill();
      alert(scoreText._text);
      this.state.start('Menu');
    }

    var gone = flames.getFirstExists(false);
    gone.reset(this.player.body.x, this.player.body.y);
    gone.play('destroy', 20, false, true);

  },

  // Same as playerHit but with rail enemy
  playerHit1: function (player, rail) {
    rail.kill();

    this.score += 30;
    scoreText.text = scoreString + this.score;

    this.lives -= 1;
    livesText.text = livesString + this.lives;

    if (this.player.health > 1) {
      this.player.health --;
    } else {
      this.player.kill();
      alert(scoreText._text);
      this.state.start('Menu');
    }

    var gone = flames.getFirstExists(false);
    gone.reset(this.player.body.x, this.player.body.y);
    gone.play('destroy', 20, false, true);

  },
  // Same as playerHit but with css enemy
  playerHit2: function (player, cascade) {
    cascade.kill();

    if (this.player.health > 1) {
      this.player.health --;
    } else {
      this.player.kill();
      alert(scoreText._text);
      this.state.start('Menu');
    }

    this.score += 15;
    scoreText.text = scoreString + this.score;

    this.lives -= 1;
    livesText.text = livesString + this.lives;

    var gone = flames.getFirstExists(false);
    gone.reset(this.player.body.x, this.player.body.y);
    gone.play('destroy', 20, false, true);

  },

  // Same as playerHit but with javascript enemy
  playerHit3: function (player, javascript) {
    javascript.kill();

    if (this.player.health > 1) {
      this.player.health --;
    } else {
      this.player.kill();
      alert(scoreText._text);
      this.state.start('Menu');
    }

    this.score += 50;
    scoreText.text = scoreString + this.score;

    this.lives -= 1;
    livesText.text = livesString + this.lives;

    var gone = flames.getFirstExists(false);
    gone.reset(this.player.body.x, this.player.body.y);
    gone.play('destroy', 20, false, true);

  },

  score:function() {

  }

};
